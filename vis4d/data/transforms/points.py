"""Pointwise transformations."""
from __future__ import annotations

from typing import TypedDict

import numpy as np

from vis4d.common.typing import NDArrayFloat
from vis4d.data.const import CommonKeys as K

from .base import Transform


class SE3Transform(TypedDict):
    """Parameters for Resize."""

    translation: NDArrayFloat
    rotation: NDArrayFloat


@Transform(in_keys=(K.points3d,), out_keys=("transforms.pc_bounds",))
class GenPcBounds:
    """Extracts the max and min values of the loaded points."""

    def __call__(
        self, coordinates: NDArrayFloat
    ) -> tuple[NDArrayFloat, NDArrayFloat]:
        """Extracts the max and min values of the pointcloud."""
        return np.stack([coordinates.min(0), coordinates.max(0)])


@Transform(
    in_keys=(K.points3d, "trasforms.pc_bounds"),
    out_keys=(K.points3d,),
)
class NormalizeByMaxBounds:
    """Normalizes the pointcloud by the max bounds."""

    def __init__(self, axes: tuple[int, int, int] = (0, 1, 2)) -> None:
        """Creates an instance of the class.

        Args:
            axes (tuple[int, int, int]): Over which axes to apply
                normalization.
        """
        self.axes = axes

    def __call__(
        self, coords: NDArrayFloat, pc_bounds: NDArrayFloat
    ) -> NDArrayFloat:
        """Applies the normalization."""
        max_bound = np.max(np.abs(pc_bounds), axis=0)
        for ax in self.axes:
            coords[:, ax] = coords[:, ax] / max_bound[ax]
        return coords


@Transform(
    in_keys=(K.points3d,),
    out_keys=(K.points3d,),
)
class CenterAndNormalize:
    """Centers and normalizes the pointcloud."""

    def __init__(self, centering: bool = True, normalize: bool = True) -> None:
        """Creates an instance of the class.

        Args:
            centering (bool): Whether to center the pointcloud
            normalize (bool): Whether to normalize the pointcloud
        """
        self.centering = centering
        self.normalize = normalize

    def __call__(self, coords: NDArrayFloat) -> NDArrayFloat:
        """Applies the Center and Normalization operations."""
        if self.centering:
            coords = coords - np.mean(coords, axis=0)
        if self.normalize:
            coords = coords / np.max(np.sqrt(np.sum(coords**2, axis=-1)))
        return coords


@Transform([], "transforms.se3")  # TODO: OK to leave this empty?
class GenRandSE3Transform:
    """Creates a random SE3 Transforms.

    The transform is generated by sampling a random translation and rotation
    from a uniform distribution.
    """

    def __init__(
        self,
        translation_min: tuple[float, float, float] = (0, 0, 0),
        translation_max: tuple[float, float, float] = (0, 0, 0),
        rotation_min: tuple[float, float, float] = (0, 0, 0),
        rotation_max: tuple[float, float, float] = (0, 0, 0),
    ) -> None:
        """Creates an instance of the class.

        Args:
            translation_min (tuple[float, float, float]): Minimum translation.
            translation_max (tuple[float, float, float]): Maximum translation.
            rotation_min (tuple[float, float, float]):  Minimum euler rotation
                angles [rad]. Applied in the order rot_x -> rot_y -> rot_z.
            rotation_max (tuple[float, float, float]): Maximum euler rotation
                angles [rad]. Applied in the order rot_x -> rot_y -> rot_z.
        """
        self.translation_min = np.asarray(translation_min)
        self.translation_max = np.asarray(translation_max)
        self.rotation_min = np.asarray(rotation_min)
        self.rotation_max = np.asarray(rotation_max)

    def __call__(self) -> SE3Transform:
        """Applies the SE3 Transform."""
        angle = np.random.uniform(self.rotation_min, self.rotation_max)
        translation = np.random.uniform(
            self.translation_min, self.translation_max
        )
        cos_x, sin_x = np.cos(angle[0]), np.sin(angle[0])
        cos_y, sin_y = np.cos(angle[1]), np.sin(angle[1])
        cos_z, sin_z = np.cos(angle[2]), np.sin(angle[2])
        rotx = np.array([[1, 0, 0], [0, cos_x, -sin_x], [0, sin_x, cos_x]])
        roty = np.array([[cos_y, 0, sin_y], [0, 1, 0], [-sin_y, 0, cos_y]])
        rotz = np.array([[cos_z, -sin_z, 0], [sin_z, cos_z, 0], [0, 0, 1]])
        rot = np.dot(rotz, np.dot(roty, rotx))
        return SE3Transform(translation=translation, rotation=rot)


@Transform(
    in_keys=(K.points3d, K.colors3d),
    out_keys=(K.points3d,),
)
class ConcatenateFeatures:
    """Concatenates all given data keys along the given axis."""

    def __init__(self, axis: int = 0):
        """Creates an instance of the class.

        Args:
            axis (int): Axis to concatenate along
        """
        self.axis = axis

    def __call__(self, *args: NDArrayFloat) -> NDArrayFloat:
        """Concatenates all given data keys along the given axis."""
        return np.concatenate(args, axis=self.axis)


@Transform(
    in_keys=(K.points3d,),
    out_keys=(K.points3d,),
)
class AddGaussianNoise:
    """Adds random normal distributed noise with given std to the data.

    Args:
        std (float): Standard Deviation of the noise
    """

    def __init__(self, noise_level: float = 0.01):
        """Creates an instance of the class.

        Args:
            noise_level (float): The noise level. Standard deviation for
                the gaussian noise.
        """
        self.noise_level = noise_level

    def __call__(self, coordinates: NDArrayFloat) -> NDArrayFloat:
        """Adds gaussian noise to the coordiantes."""
        return (
            coordinates
            + np.random.randn(*coordinates.shape) * self.noise_level
        )


@Transform(
    in_keys=(K.points3d,),
    out_keys=(K.points3d,),
)
class AddUniformNoise:
    """Adds random normal distributed noise with given std to the data.

    Args:
        std (float): Standard Deviation of the noise
    """

    def __init__(self, noise_level: float = 0.01):
        """Creates an instance of the class.

        Args:
            noise_level (float): The noise level. Half the range of the
                uniform noise. The noise is sampled from
                [-noise_level, noise_level].
        """
        self.noise_level = noise_level

    def __call__(self, coordinates: NDArrayFloat) -> NDArrayFloat:
        """Adds uniform noise to the coordinates."""
        return coordinates + np.random.uniform(
            -self.noise_level, self.noise_level, coordinates.shape
        )


@Transform(
    in_keys=(K.points3d, "transforms.se3"),
    out_keys=(K.points3d,),
)
class ApplySE3Transform:
    """Applies a given SE3 Transform to the data."""

    def __call__(
        self, coordinates: NDArrayFloat, transform: SE3Transform
    ) -> NDArrayFloat:
        """Applies a SE3 Transform."""
        if coordinates.shape[-1] == 3:
            return (transform["rotation"] @ coordinates.T).T + transform[
                "translation"
            ]
        if coordinates.shape[-2] == 3:
            return (transform["rotation"] @ coordinates).T + transform[
                "translation"
            ]
        raise ValueError(f"Invalid shape for coordinates: {coordinates.shape}")


@Transform(
    in_keys=(K.points3d, "transforms.se3.rotation"),
    out_keys=(K.points3d,),
)
class ApplySO3Transform:
    """Applies a given SO3 Transform to the data."""

    def __call__(
        self, coordinates: NDArrayFloat, transform: NDArrayFloat
    ) -> NDArrayFloat:
        """Applies a given SO3 Transform to the data."""
        if coordinates.shape[-1] == 3:
            return (transform @ coordinates.T).T
        if coordinates.shape[-2] == 3:
            return (transform @ coordinates).T
        raise ValueError(f"Invalid shape for coordinates: {coordinates.shape}")


@Transform(
    in_keys=(K.points3d,),
    out_keys=(K.points3d,),
)
class TransposeChannels:
    """Transposes some predifined channels."""

    def __init__(self, channels: tuple[int, int] = (-1, -2)):
        """Creates an instance of the class.

        Args:
            channels (tuple[int, int]): Tuple of channels to transpose
        """
        self.channels = channels

    def __call__(self, coordinates: NDArrayFloat) -> NDArrayFloat:
        """Transposes some predifined channels."""
        return coordinates.transpose(*self.channels)
